# 第七章 面向对象设计方法

## 7.1 面向对象设计方法综述

> 面向对象的软件设计方法基于UML，将软件需求分析阶段获得的用例模型和领域模型的内容运用一系列软件设计原则转换为软件设计阶段设计模型的动态结构和静态结构。

在软件的需求分析阶段只需要考虑问题域和系统职责，而到了软件设计阶段则需要考虑如何将系统职责映射到软件的功能上，并且还需要进一步定义那些软件对象具有这些功能，以及对象之间如何协调完成用例规定的内容。

**为什么我们要详细学习面向对象设计方法呢？**

- 使反映问题域本质的总体框架和组织结构长期稳定，而细节可变。

- 把稳定部分（问题域部分）和可变部分（与实现相关的部分）分开，使系统能从容地适应变化
- 分析结果重用，有利于同一个分析用于不同的设计和实现。

简单地说，就是形成一个大致的框架，使得你的代码是有根据地编写，而不是想到啥写啥。



面向对象设计OOD主要包括三方面的工作：

- 软件体系结构设计
- 用例实现方案设计
- 用户界面设计

## 7.2 模型层次化

所谓的模型层次化，也就是把软件设计组织成为类或组件的层次/集合，这些类或者组件共同完成某一用例。

在实际的面向对象软件设计的过程中，有很多可以参考和借鉴的分层结构，比如MVC。在本章中，我们将采用以下的分层结构：

![image-20200510101147286](%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95.assets/image-20200510101147286.png)

- ==用户界面层==：就是GUI，用于定义和表示用于所有角色定义的功能操作

- 用例模型定义的用例主要通过==控制器层==和==业务逻辑层==来实现。

  - 控制器层的核心用途在于解耦界面层对象与业务对象之间的关系；控制类的对象主要用于接受界面层提交的请求并管理和分析这些请求业务的类型，进而转发给业务逻辑层的业务对象。

  - 业务逻辑层的对象主要用于处理核心的业务逻辑，即完成用例定义的功能需求。业务逻辑层对象完成调用后，根据需求可以将业务数据传递给持久化层的对象，进行持久化保存。

  - > 这里需要注意的是：一个用例可能对应于多个业务逻辑层的软件对象。

- ==持久化层==的主要用途是永久存储、检索、更新和删除对象的能力，使底层的存储技术不暴露出来。

- 最后，==系统管理类==为软件体系结构提供操作系统相关的功能，通过包装特定于操作系统的特性，使软件与操作系统分离，这样增加应用的可移植性。



在这里，我们需要明确的一点是，模型层次化，主要是为了减少层次之间的耦合度，增加系统的可移植性。那么为了减少耦合度，我们需要限制层次之间的协作，并允许同一层次之间的软件对象可以进行协作。例如：GUI层A对象能够把信息发送到GUI层B对象；业务逻辑层A对象能够传递信息到业务逻辑层B对象。

通过把消息的流动限制在一个方向，也可以减少类与类之间的耦合从而大大增加系统的可移植性和灵活性。把消息流动限制在一个方向，可以减少类之间的依赖性。

每个层次的类都可以与系统管理类进行交互。系统管理类实现软件的基本特性，比如进程间通信（IPC）、用于与其他计算机上的类进行通信的服务类，以及进行审计日志的类。



### 7.2.1 控制器层对象的设计原则

问题引入：软件系统中哪一个对象负责接收使用者发送的消息？

参考答案：

1. 请求直接发送给业务逻辑层的对象进行处理。这样做的好处是简单方便，但是可能会导致一些安全漏洞。
2. 请求被某一个专职对象接受（检查请求的有效性，非法请求直接丢弃或回绝）并转发应用逻辑层对象进行逻辑处理。

### 7.2.2 业务逻辑层对象的设计原则

一个软件，最重要的还是需要实现其系统功能，而业务逻辑层就是定义软件的系统功能。

- 在**面向对象==分析==阶段**已经识别出问题域中关键的概念，该阶段关注的是概念的本质含义以及属性。（面向客观世界）
- 在**面向对象==设计==阶段**，将会对这些概念增加操作（方法），并进行必要的修改和调整，使之成为设计模型中业务层的类。（从客观世界中提取并精炼）
- 上述的一致性体现了OOA和OOD之间不存在结构化方法中分析与设计的鸿沟，两者能够紧密衔接。

> 比如说在我们的软件“分布式温控系统”中，

### 7.2.3 持久化层对象的设计原则

问题引入：

- 业务逻辑层对象处理之后的业务数据如何保存到数据库？
- 如何提高业务数据的访问性能？

持久化层提供存储、检索、更新和删除对象实例的基础结构。

持久化层将“对数据库的操作”封装起来，提供专门负责数据管理的功能，向业务对象提供持久化服务，从而使数据库变化对业务领域的影响的范围局部化。





## 7.3 设计用例实现方案

面向对象设计的最终结果是软件设计模型的静态结构，在得到静态结构之间，我们必须先得到动态结构。

- ==动态结构==：针对用例模型中的每个用例进行设计，其设计过程称为**用例实现**
- ==静态结构==：针对某个问题域（某个用例）或者系统级所有动态结构中确定的软件对象之间协作（交互）关系的一种表示方法。通常使用UML的类图、组件图、包图表示软件设计模型中的静态结构。（确定类之间的关系和类的操作和方法）

用例实现指的是在设计模型中描述分层结构中相互协作的软件对象如何实现用例的各个特定场景，包括所有成功和失败场景。

用例实现的设计方案就是找出软件分层结构中每个层次所需哪些软件对象来参与、协同工作、以实现用例的各个场景，即针对用例模型系统顺序图中的每个角色发送给系统对象的消息，软件系统的分层结构中有哪些软件对象负责接收消息的请求、处理请求的内容、处理后的数据存储以及返回给角色的处理结果。

简单的说：**用例实现的设计方案**就是找出软件对象，并给出这些对象的交互场景以及实现用例的要求（使用UML的时序图来绘制）。



### 7.3.1 类职责分配（Grasp）模式

设计类的来源有两部分：

- 由领域模型中的概念类转换而来
- 为实现而新增的一些类，如负责对象持久化的类，负责通信的类。



核心思想：每个设计类都有明确的职责。对象的职责可以分为两种类型：

1. 了解型职责
   - 对象了解自己私有的封装数据
   - 了解关联的对象
   - 了解能够派生或者计算的事务
2. 行为型职责
   - 对象自身能执行一些行为：创建一个对象或进行计算
   - 对象能启动其他对象中的动作（调用）
   - 对象能控制或协调其他对象中的活动



> 模式的组成
>
> - 模式名称：助记名，用来描述模式的问题、解决方案和效果
> - 问题：何时使用模式。模式的使用问题域
> - 解决方案：描述了设计的组成部分、组成部分之间的相互关系以及各自的职责和写作方式
> - 效果：描述了模式应用的效果和使用模式应权衡的问题
>
> Grasp设计模式：主要用于寻找并确定软件对象，从宏观角度解决软件设计问题（适用于初学者）
>
> GoF设计模式：主要使用Interface的特点，增加软件结构的灵活度，降低对象之间的耦合度，解决软件设置中局部紧耦合以及扩展性的问题；



#### 控制器模式

问题引入：第一个接收系统事件的软件对象是什么？哪一个软件对象负责接收和处理一个系统输入事件

解决方案：把接收和处理系统事件的职责分配给位于控制器层的对象

外观控制器：代表整个系统或者某个设备，称为外观控制器（Facade Controller），通常以系统或者设备名称命名

用例控制器：仅仅针对某一用例的控制器。用例名_控制器的形式命名这些控制器对象

#### 创建者模式

问题引入：那个对象应该负责产生类的实例？（操作契约中对象实例的创建）

什么时候使用创建者模式呢？

- B聚合或包含对象A
- B记录对象A
- B密切使用对象A
- B拥有创建对象A所需要的初始化数据（B是创建对象A的信息专家）

#### 信息专家模式

给对象分配职责的通用原则：将职责分配给拥有履行职责所必须信息的类，即信息专家。换言之，对象具有处理自己拥有信息的职责或能力；根据交互图上的对象，接收消息的对象一定具有处理该消息的职责和能力，为此可以根据消息的名称和参数为该软件对象定义一个具有同名的方法。



#### 一个超市POS机实例

- 超市柜台收银系统，简称POS机系统

- 已知条件：
  - 角色：收银员Cashier
  - 用例：处理销售（Sell）和处理支付（Payment）
  - SSD
  - 操作契约
  - 领域模型

![image-20200510160414920](%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95.assets/image-20200510160414920.png)

>**用例说明**
>
>成功场景：
>
>1. 顾客携带商品到达POS机收费口
>
>2. 收银员开始一次新的销售
>
>3. 收银员输入商品标识
>
>4. 系统记录单件商品，并显示该商品的描述、价格、累加值。
>
>收银员重复3～4步，直到商品输入结束。
>
>5. 系统显示总值并计算税金。
>
>6. 收银员请顾客付款。
>
>7. 顾客支付，系统处理支付。
>
>8. 系统记录完整的销售信息，并将销售和付款信息发送到外部的帐务系统。
>
>9. 系统打印收据
>
>10. 顾客带着商品和收据离开。
>
>==一般来说，产品经理可以给出一个用例说明，程序员根据用例说明，写出SSD并且找出对应的领域模型（概念类）等等。==

<img src="%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95.assets/image-20200510160514674.png" alt="image-20200510160514674" style="zoom:67%;" />

![领域模型](%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95.assets/image-20200510161116481.png)



##### 设计步骤1：

1. 选择系统架构
   - 基于B/S的分层架构，要求至少能体现控制器层和应用逻辑层
2. 回顾并分析序曲模型
   - 根据用例模型，主要的用例是：处理销售（Sell）用例
   - 根据SSD得到的4个系统时间：
     - makeNewSale
     - enterItem
     - endSale
     - makePayment

3. 下一步设计：根据选择的系统架构，使用UML的交互图，为该用例的每一个系统时间确定对应的软件对象，并根据操作契约确定对象之间的关系。

##### 设计步骤2：

- 对象设计：makeNewSale
- 操作契约：
  - 创建一个Sale实例s（实例创建）
  - s和Register建立关联（关联形成）
  - 初始化s的属性（属性修改）

> 问题：如何为系统操作makeNewSale选择控制器
>
> 解决方案： 根据“控制器”模式，要么使用“外观控制器”， 要么使用“用例控制器”。在本案例中，由于只存在少量的系统操作，为此选用“外观控制器”， 以Register作为设计模型中的软件对象。
>
> 注意：此时的Register已经不再是物理终端设备

- 设计用例实现过程
  - Register作为控制器对象接收系统时间makeNewSale
  - 根据操作契约第一条：创建一个Sale实例s，则Register具有创建s的职责；
  - Sale实例是Register创建，则形成了缺省的关联关系；
  - 操作契约：初始化s，即该实例能够记录多个销售的商品SalesLineItem，根据领域模型的关系Sale实例负责创建SalesLineItem的一个数组或集合；

![image-20200510162159987](%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95.assets/image-20200510162159987.png)

---

- 对象设计：enterItem()
- 操作契约：
  - 创建一个SalesLineItem实例sli（实例创建）
  - sli和当前的Sale建立关联（关联形成）
  - sli.quantity变成参数quantity（属性修改）
  - 实例sli在itemID匹配的基础上与ProductSpecification建立关联（关联形成）

> 问题：
>
> 1. 控制器类的选择
>
>    - 该系统事件属于同一个用例，为此控制器对象无论是外观还是用例控制器，都应该是Register；
>
> 2. 是否要显示商品的描述和价格？
>
>    - 显然是需要在扫描物品时根据物品id找到对应的物品信息，关键问题是哪个对象负责查找？
>
>      方案一：Register
>
>      方案二：Sale
>
> 3. 创建新的SaleLineItem
>
>    - 显然是需要在扫描物品时根据物品id找到对应的物品信息，关键问题是哪个对象负责查找？
>
>      方案一：Register
>
>      方案二：Sale
>
> 4. 寻找ProductDescription
>
>    - 根据领域模型可知ProductCatalog与ProductDescription相关联

![image-20200510163535007](%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95.assets/image-20200510163535007.png)





































































